<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Redis-01-NoSQL简介及Redis数据库安装]]></title>
    <url>%2F2018%2F04%2F16%2FRedis-01-NoSQL%E7%AE%80%E4%BB%8B%E5%8F%8ARedis%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[NoSQL非关系型数据库的概念及最流行的非关系型数据库Redis数据库的安装 一.NoSQL简介1.1 NoSQL概述NoSQL即not only SQL（不仅仅是SQL）的意思，学名叫做非关系型数据库，和我们常见的关系型数据库（如MySQL，Oracle）在原理上有很大差异非关系型数据库能很好解决web2.0纯动态网站面对的高并发和规模大扩展性受限等问题。非关系型数据库可以解决三个关系型数据库难以解决的问题。1.数据库高并发读写。2.对海量数据的高效率存储和访问。3.数据库的高扩展性和高可用 1.2 NoSQL数据库的分类关系型数据库有MySQL，Oracle等不同的种类。非关系型数据库也有很多不同的产品种类，所有这些产品根据其存储方式的不同主要分为4大类： 种类 典型产品 应用方向 数据模型 优势 劣势 键值（key-value） Redis,Voldemort,Oracle BDB 内容缓存，主要用于处理大量数据的高访问负载，也用于一些日志系统等等。 key-value（键值对） 查询速度快 数据没有结构 列存储数据库 Cassandra,HBase,Riak 分布式文件系统 以列簇式存储，将同一列数据存在一起 查找速度快，可扩展性强，更容易进行分布式扩展 功能相对局限 文档型数据库 CouchDB, MongoDb web应用 key-value,value是结构化的数据 数据结构要求不严格，表结构可变，不需要像关系型数据库一样需要预先定义表结构 查询性能不高，而且缺乏统一的查询语法。 图形(Graph)数据库 Neo4J,InfoGrid,Infinite Graph 社交网络，推荐系统等。专注于构建关系图谱 图结构 利用图结构相关算法。比如最短路径寻址，N度关系查找等 很多时候需要对整个图做计算才能得出需要的信息，而且这种结构不太好做分布式的集群方案 1.3 NoSQL数据库的特点NoSQL数据库最重要的优点就是在大数据的存取上具备关系型数据库无法比拟的性能优势。主要是因为其如下特点 1）易扩展非关系数据库去掉了关系数据库的关系特性。数据之间无关系，这样就容易扩展。 2）高数据量时的高性能非关系数据库在数据量非常大时依然能具有很高的读写性能 3）灵活的数据模型非关系数据库无需实现为要存储的数据建立字段，随时可以存储自定义的数据格式。而建立字段在关系型数据库中确实一件必须的事情，在数据量比较大时，建立字段是一个相当麻烦的事情 4）高可用非关系数据库在不影响性能的情况下可以方便的实现高可用的架构。 二.Redis简介Redis是一个开源的使用C语言编写的Key-Value类型的非关系数据库，并提供多种语言的API。Redis是当前最流行的非关系数据库之一。redis是一个key-value存储系统。和Memcached类似，它支持存储的value类型相对更多，包括string(字符串)、list(链表)、set(集合)、zset(sorted set –有序集合)和hash（哈希类型）。这些数据类型都支持push/pop、add/remove及取交集并集和差集及更丰富的操作。在此基础上，redis支持各种不同方式的排序。与memcached一样，为了保证效率，数据都是缓存在内存中。区别的是redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实现了master-slave(主从)同步。redis的官网地址：redis.io目前，Vmware在资助着redis项目的开发和维护。 三.Redis安装Redis一般安装在Linux系统上，Redis是C语言编写的，所以Redis的安装和运行需要C语言环境 Redis安装步骤：1）安装C语言环境使用yum自动安装：运行命令yum install gcc-c++ 2）下载安装包从Redis官网下载最新的Redis安装包，我是用的版本是redis-3.0.0也可以从CSDN下载：redis安装包 3）解压安装包到解压文件到/usr/local目录下，也可以解压到别的目录运行命令tar -xvf redis-3.0.0.tar.gz -C /usr/local 4）编译Redis进入解压完毕的redis-3.0.0目录，运行make命令redis-3.0.0目录目录下有一个Makefile文件，所以可以直接运行make命令使用C语言进行编译 5）安装Redis在redis-2.6.16目录中，运行make PREFIX=/usr/local/redis install命令安装redis到路径/usr/local/redis中，也可以安装到别的目录下 6）完善配置文件拷贝redis-3.0.0中的配置文件 redis.conf 到Redis安装目录/usr/local/redis/bin中 7）启动Redis（前端模式）在bin目录下执行命令redis-server redis.conf显示如下表示安装成功可以使用，使用Ctrl+C退出 8）远程连接redis在linux防火墙中开放Redis的默认端口6379运行命令：/sbin/iptables -I INPUT -p tcp –dport 6379 -j ACCEPT 开放端口/etc/rc.d/init.d/iptables save 保存配置 9）启动Redis（后端模式）前端模式不易于操作，所以Redis启动常用后端模式，修改配置文件，redis.conf进入redis.conf文件所在的目录：/usr/local/redis/bin，运行命令vi redis.conf，更改daemonize参数，默认是no，修改为yes，保存退出 再次进入redis的bin目录，运行命令./redis-server redis.conf没有任何显示表示后端模式启动成功 #四.Redis配置文件redis.confRedis最主要的配置都在它的配置文件redis.conf中，启动Redis时需要指定使用那个配置文件。redis.conf中有很多设置是在应用中需要根据情况更改的，以下展示redis.conf中各种配置的含义（按文件中的顺序列举）]]></content>
      <categories>
        <category>数据库</category>
        <category>NoSQL</category>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
        <tag>非关系型数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JSP技术-02-内置对象_作用域_EL表达式_JSTL标签库]]></title>
    <url>%2F2018%2F04%2F15%2FJSP%E6%8A%80%E6%9C%AF-02-%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1_%E4%BD%9C%E7%94%A8%E5%9F%9F_EL%E8%A1%A8%E8%BE%BE%E5%BC%8F_JSTL%E6%A0%87%E7%AD%BE%E5%BA%93%20%2F</url>
    <content type="text"><![CDATA[和JSP相关的一些被封装的内容，主要涉及底层工作原理 一.九大内置对象几乎每个JSP页面在处理数据时都要用到request，response，context等对象，所以，JSP2.0规范中定义9个内置对象（隐式对象），将在JSP中常用的对象封装成了内置对象。在JSP页面中，内置对象是由JSP默认创建的，可以直接在JSP页面中直接使用，不需要创建9个内置对象的类型及功能： 名称 类型 功能 out javax.servlet.JspWriter 用于在页面中输出内容 request javax.servlet.http.HttpServletRequest 获取用户的请求信息 reponse javax.servlet.http.HttpServletResponse 服务器返回信息给浏览器 config javax.servlet.ServletConfig 封装了服务器的配置，可以用来获得初始化参数 session javax.servlet.http.HttpSession 可以用来获取服务器端存储的信息 application javax.servlet.ServletContext 所有请求共享的信息 page java.lang.Object 当前页面经过转换后的Servlet类的实例 pageContext javax.servlet.jsp.PageContext JSP页面容器，可以用来或取该JSP页面中的属性和对象的值 exception java.lang.Throwable JSP页面的异常信息 pageContext对象：pageContext对象的功能： 1）可以用来获取其他内置对象 在JSP页面中，使用pageContext对象的getXXX方法可以获取JSP页面中的其他8个内置对象，如想要获取当前页面的request对象，可以调用pageContext的getPageContext( )方法。pageContext对象是javax.servlet.jsp.PageContext类的实例对象，它代表当前JSP页面的运行环境 2） 可以用来存储数据，pageContext对象存储数据是通过操作属性来实现的 方法 功能 void setAttribute(String name,Object value,int scope) 用于设置pageContext对象的属性 Object getAttribute(String name ,int scope) 用于获取pageContext对象的属性 Object findAttribute(String name) 从4个域对象中查找名称为name的属相 参数name指定属性名称，参数scope指定属性作用范围，作用范围参数可以是下面4个值（对应4大域，下面会细讲） 属性值 作用范围 PageContext.PAGE_SCOPE 整个页面 PageContext.PEQUEST_SCOPE 一次请求 PageContext.SESSION_SCOPE 一次会话 PageContext.APPLICATION 整个web应用 使用findAttribute( )方法查找域中的属性时，会按照page，request，session和application的顺序（范围越小，优先级越高）进行查找 二.四大域“域”的本质是一块存储数据的区域，底层是一个map集合，集合的键是属性名，值是属性值。由于这个map集合是属于JSP中的对象的，而不同对象的生命周期和作用范围又不同，所以“域”的作用范围也不同，只能在固定的范围内存取值。JSP页面中有4个对象常被用来存取，传递数据，它们被称为4大域4大域的名称，类型及作用范围： 属性值 作用范围 域名称 域对象类型 PageScope 当前页面 pageContext PageContext RequestScope 即从浏览器发出请求到服务器收到请求开始处理，通常只涉及一个页面，如果有请求的转发，则涉及多个页面 request HttpServletRequest SessionScope 浏览器和服务器的一次会话，可以在多个请求间共享数据 session HttpSession Application 整个项目范围，可以在多次会话间共享数据 application ServletContext 三.EL表达式EL全名为Expression Language，是一种简单易用的数据访问语言，EL表达式简化了获取Servlet域对象中数据的方式，使JSP页面中的代码更加简洁 3.1 EL的语法EL表达式的形式：${ 表达式 } 3.2 EL表达式与内置对象3.2.1 EL表达式可以获取4大域中的属性的值（直接调用域对象）例如：获取页面中的name属性的值 { pageScope.name } 范例：使用EL表达式获取内置对象中的数据123456789&lt;%=pageContext.getAttribute(&quot;name&quot;)%&gt;&lt;%=request.getAttribute(&quot;name&quot;)%&gt;&lt;%=session.getAttribute(&quot;name&quot;)%&gt;&lt;%=application.getAttribute(&quot;name&quot;)%&gt;$&#123;pageScope.name&#125;$&#123;requestScope.name&#125;$&#123;sessionScope.name&#125;$&#123;applicationScope.name&#125; EL表达式获取其他内置对象中属性的值： 分类 使用的方法 获取的值 请求参数 param 获得一个请求参数 请求参数 paramValues 获得一组请求参数 请求头 header 获得一个请求头 请求头 headerValues 获得一组请求头 JSP上下文对象 pageContext 全局初始化参数 initParam cookie cookie 3.2.2 获取请求参数：请求路径：/e3mall/userServlet？method=login&amp;username=xxx&amp;password=123&amp;password=111获取参数： 功能 EL表达式 获取一个参数 ${param.username} 获取一组参数 ${paramValues.password} 获取一组参数中的一个 ${paramValues.password[0]} 3.2.3 获取请求头 功能 EL表达式 获取请求头中的host参数 ${header.accept} 获取请求头中的编码参数（参数只有一个） ${header[‘accept-Encoding’] 获取请求头中的编码参数（参数为一个数组） ${headerValues[‘accept-Encoding’][0]} 3.2.4 获取pageContext中的属性的值获取项目路径： 使用JSP标签 使用EL表达式 &lt;%=((HttpServletRequest)pageContext.getRequest()).getContextPath()%&gt; ${ pageContext.request.contextPath } 3.2.5 获取项目的初始化参数（web.xml文件中的配置信息）web.xml文件的配置 1234&lt;context-param&gt; &lt;param-name&gt;namespace&lt;/param-name&gt; &lt;param-value&gt;/e3mall&lt;/param-value&gt;&lt;/context-param&gt; 获取namespace参数的值：${ intitParam.person }5.获取cookie中的值${ cookie.loginUser }EL获取cookie不是直接调用底层的方法，而是对底层方法进行了部分封装和加强。cookie没有根据属性名操作属性值的API，EL的底层使用request.getCookies( )获得所有cookie，然后遍历并存放到Map中（Map &lt; name,obj &gt;） 四.JSTL技术：JSTL全名为JSP Standard Tag Library ，即JSP标准标签库。使用JSP标签可以降低JSP页面的复杂度，增强代码的重用性，所以经常使用JSP的人就制作了很多自定义的JSP标签，但是制作这些标签的人并不属于同一个团队，所以有很多标签功能相同，导致学习和使用很不方便，为了方便开发者的使用，sun公司制作了一套标准标签库，即JSTLJSTL是由5个不同功能的标签库组成的： 标签库 对应的URL 标签前缀 Core http://java.sun.com/jsp/jstl/core c I18N http://java.sun.com/jsp/jstl/fmt fmt SQL http://java.sun.com/jsp/jstl/sql sql XML http://java.sun.com/jsp/jstl/xml x Functions http://java.sun.com/jsp/jstl/functions fn 常用的JSTL标签： 4.1 if标签用于执行判断 语法：1234例一：&lt;c:if test=&quot;Boolean&quot;&gt; $&#123;param&#125;&lt;/c:if&gt; Boolean的值为true则执行标签体中的内容，查找4大域中param属性的内容并显示1234例二：&lt;c:if test=&quot;Boolean&quot; var=&quot;param&quot; scope=&quot;Scope&quot; [scope=&quot;&#123;page|request&#125;&quot;]&gt; $&#123;param&#125;&lt;/c:if&gt; 将Boolean的值（true或false）赋给param属性，并存放到指定的作用域，若Boolean的值为true执行标签体中内容 属性名 功能 test属性 用于设置逻辑表达式，逻辑表达式的计算结果为true则执行标签体中内容，为false则不执行 var属性 用于指定逻辑表达式的结果的名称 scope属性 用于指定var属性声明的变量的作用范围，默认值为page 4.2 forEach标签用于迭代集合中的元素 1）基本语法：12345例一：&lt;c:forEach var=&quot;item&quot; varStatus=&quot;status&quot; items=&quot;$&#123;pageBean&#125;&quot;&gt; &lt;td align=&quot;center&quot; width=&quot;18%&quot;&gt;$&#123;status.count&#125;&lt;/td&gt; &lt;td align=&quot;center&quot; width=&quot;17%&quot;&gt;$&#123;item.pname&#125;&lt;/td&gt; &lt;/c:forEach&gt; 迭代pageBean集合，并输出元素的序号（从1开始），及元素的pname属性的值 属性名 功能 var属性 指定当前迭代到的元素保存到page域中的名称 items属性 指定被迭代的集合对象 varStatus属性 指定存有当前迭代到的元素的信息的对象保存到page域中的名称 begin属性 指定从集合的第几个元素开始迭代，默认从0开始 step属性 指定迭代因子的增量 2）varStatus属性： 用于设置一个javax.servelt.jsp.jstl.core.LoopTagStatus类型的变量，这个变量包含了从集合中取出的元素的状态信息 属性名 返回值类型 功能 count int 元素在集合中的序号，从1开始计数 index int 元素在集合中的索引，从0开始计数 first boolean 是否是集合的第一个元素 last boolean 是否是集合的最后一个元素 3）迭代Map集合：12345例二：&lt;c:forEach var=&quot;item&quot; items=&quot;$&#123;pageBean&#125;&quot;&gt; &lt;td align=&quot;center&quot; width=&quot;18%&quot;&gt;$&#123;item.key&#125;&lt;/td&gt; &lt;td align=&quot;center&quot; width=&quot;17%&quot;&gt;$&#123;item.value&#125;&lt;/td&gt; &lt;/c:forEach&gt; 迭代pageBean（Map集合）中的元素，将每个元素的key和value的值输出 迭代List和Set集合时，var声明的对象就是集合中的元素。而在迭代Map集合时，var声明的则是键和值的关系对象]]></content>
      <categories>
        <category>前端</category>
        <category>JSP</category>
      </categories>
      <tags>
        <tag>JSP内置对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo+GitHub搭建个人博客]]></title>
    <url>%2F2018%2F04%2F14%2FHexo%2BGitHub%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[昨天做了这个个人博客，今天总结一下，把做法写成了这篇博客 一.前言1.Hexo和GitHub你现在看到的就是我用GitHub Pages搭建的个人博客，主要用到的东西就是GitHub和Hexo，Hexo是一个博客框架，它的主要功能是根据配置文件和博客文章生成静态的网页，能够放在网站上供人浏览。GitHub就很著名了，我就不介绍了 2.Hexo和GitHub需要的安装环境Hexo的使用需要先安装node.js，GitHub则需要在本地安装Git 在node.js官网进行下载安装文件有时会很慢，不相等可以从这里下node.js安装包Git的下载和配置在我的另一篇博客：Git安装配置与GitHub注册及简单使用 二.Hexo的安装前面的工作做好了以后，现在可以安装Hexo了。安装Hexo很简单，只需要几个命令就可以了。新建一个文件夹，用于放置Hexo的程序文件，我建的文件路径是D:\BlogProject\hexo 运行命令：npm install -g hexo-cli 此命令用来下载Hexo，需要花费一段时间，整个过程中需要等待的最久的一部，我等了5分钟，命令执行后D:\BlogProject\hexo路径下还没有文件 使用命令：hexo -v 查看版本命令，如果出现以下信息说明Hexo已经成功下载 使用命令：hexo init 执行后Hexo的程序文件出现在D:\BlogProject\hexo文件中，出现下图红字圈出的一段话说明Hexo安装完成，可以使用了 运行命令：hexo init Hexo的运行还需要部分组件，运行此命令安装必要的组件，Hexo还支持集成第三方应用，第三方应用的使用常常也需要安装指定的组件 三.Hexo的简单使用Hexo的命令Hexo没有界面式的客户端，操作Hexo都是使用Hexo命令，下面介绍几个常用的Hexo命令： 12341.Hexo clea 清空Hexo生成的静态页面2.Hexo g 根据配置文件及markdown文件生成静态页面3.Hexo d 将Hexo部署到远程服务器上4.Hexo s 在本地启动Hexo服务 Hexo有很多命令，不过我用Hexo搭建博客全程只用到了上述4个命令，如果你想学其他命令，可以去Hexo的官网Hexo官方文档 使用Hexo命令操作Hexo既然Hexo已经安装好了，那就试用一下，使用默认配置运行命令：hexo g，生成静态页面 运行命令：hexo s，开启本地服务，这时可以通过4000端口访问Hexo生成的静态网页，Ctrl+C关闭服务后不能再访问 四.Hexo连接GitHub配置SSH key我们以上的工作使得我们可以在本地访问Hexo生成的博客，连接GitHub并部署到服务器后才能让所有人都能访问 向GitHub部署前，必须保证SSH key能够使用（SSH key可以理解为用于连接位于本地的Git和位于远程服务器的GitHub的一个工具），具体的操作请参见我的博客GitHub配置SSH key 在GitHub创建Repositories创建一个Repositories用于在GitHub的服务器部署Hexo的静态网页，对其原理有兴趣的可以百度GitHub Pages注意创建的Repositories的名称是有特殊要求的，因为Hexo配置文件中的规定，所以需要按照特定的格式，即：yoursite.github.io，yoursite指的是你的GitHub的用户名（不是昵称） 创建完成后在Hexo的根目录下（我的是：D:\BlogProject\hexo）找到_config.ym文件打开，这个文件是Hexo的总配置文件。 找到如下一段配置（我的是已经配置完成的）123456# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repository: https://github.com/JavaStudenttwo/JavaStudenttwo.github.io.git branch: master 按如上边我的示例进行配置，其中repository要填自己刚新建的repository的路径点下图位置复制路径 将Hexo生成的静态网页部署到GitHub只需要运行命令 hexo d 即可 然后在浏览器中输入网址“yoursite.github.io”（yousite指你的用户名）即可看到你的个人博客，但是页面真的很丑，不过Hexo可以更换主题，并进行其他功能的添加，这些操作在Hexo的官网上都有很详细的讲解Hexo官方文档]]></content>
      <categories>
        <category>GitHub</category>
      </categories>
      <tags>
        <tag>GitHub</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Solr分析器IK-analyzer配置及错误java.lang.AbstractMethodError解决]]></title>
    <url>%2F2018%2F04%2F13%2FSolr%E5%88%86%E6%9E%90%E5%99%A8IK-analyzer%E9%85%8D%E7%BD%AE%E5%8F%8A%E9%94%99%E8%AF%AFjava.lang.AbstractMethodError%E8%A7%A3%E5%86%B3%2F</url>
    <content type="text"><![CDATA[今天在给Solr配置IK-analyzer时报错，java.lang.AbstractMethodError，在网上查了查发现是IK版本过低，但是找了好久也没找到新版的，于是自己做了一个Jar包 一.Solr使用中文分析器IK-analyzer时报错java.lang.AbstractMethodError错误如下图所示 原因是Solr的版本和IK-analyzer的版本不匹配，IK-analyzer版本过低，现在大家能够在网上下到的IK-analyzer版本一般都是IKAnalyzer2012FF_u1，这个版本已经相当老旧了，这里提供一个较新版本的IK-analyzer：ik_analyzer_solr6 更换Jar后 二.IK-analyzer中文分析器IKAnalyzer是一个开源的，基于java语言开发的轻量级的中文分词工具包。它是以开源项目Lucene为应用主体的，结合词典分词和文法分析算法的中文分词组件。新版本的IKAnalyzer3.0则发展为 面向Java的公用分词组件，独立于Lucene项目，同时提供了对Lucene的默认优化实现。 使用Solr一般都会配置中文分析器，IKAnalyzer是应用最广的中文分析器，但是在网上能下载到IKAnalyzer版本都比较旧，这是因为这是个开源项目而且原作者好像不太想维护了，所以Solr不断更新，IKAnalyzer一直不更新，渐渐地IKAnalyzer就不能用了 不过，好在IKAnalyzer的作者把项目发布到了GitHub上，虽然没有见到IKAnalyzer的最新的Jar包但是这个项目还是更新了，而且Solr6可以使用，我fork了这个项目并把它打成了jar包，链接放到了上边 三.IK-analyzer的配置##3.1 把中文分析器添加到工程中。把ik-analyzer-solr6.jar文件添加到Tomcat中的solr工程的lib目录下把扩展词典文件ext_stopword.dic、配置文件IKAnalyzer.cfg.xml放到solr工程的WEB-INF/classes目录下 ##3.2 配置一个FieldType，制定使用IKAnalyzer修改schema.xml文件（版本不同文件名称可能不同，6以上版本应该是managed-schema文件）修改Solr的schema.xml文件，添加FieldType： 123&lt;fieldType name=&quot;text_ik&quot; class=&quot;solr.TextField&quot;&gt; &lt;analyzer class=&quot;org.wltea.analyzer.lucene.IKAnalyzer&quot;/&gt;&lt;/fieldType&gt; ##3.3 配置业务域，type制定使用自定义的FieldType设置业务系统Field，在schema.xml文件中添加： 123456789&lt;field name=&quot;item_title&quot; type=&quot;text_ik&quot; indexed=&quot;true&quot; stored=&quot;true&quot;/&gt;&lt;field name=&quot;item_sell_point&quot; type=&quot;text_ik&quot; indexed=&quot;true&quot; stored=&quot;true&quot;/&gt;&lt;field name=&quot;item_price&quot; type=&quot;long&quot; indexed=&quot;true&quot; stored=&quot;true&quot;/&gt;&lt;field name=&quot;item_image&quot; type=&quot;string&quot; indexed=&quot;false&quot; stored=&quot;true&quot; /&gt;&lt;field name=&quot;item_category_name&quot; type=&quot;string&quot; indexed=&quot;true&quot; stored=&quot;true&quot; /&gt;&lt;field name=&quot;item_keywords&quot; type=&quot;text_ik&quot; indexed=&quot;true&quot; stored=&quot;false&quot; multiValued=&quot;true&quot;/&gt;&lt;copyField source=&quot;item_title&quot; dest=&quot;item_keywords&quot;/&gt;&lt;copyField source=&quot;item_sell_point&quot; dest=&quot;item_keywords&quot;/&gt;&lt;copyField source=&quot;item_category_name&quot; dest=&quot;item_keywords&quot;/&gt;]]></content>
      <categories>
        <category>Solr</category>
      </categories>
      <tags>
        <tag>Solr</tag>
        <tag>IK-analyzer</tag>
        <tag>分析器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nginx入门]]></title>
    <url>%2F2018%2F04%2F13%2FNginx%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[Nginx是一种在大型项目中很常见的服务器，本文将对其进行简单的介绍 一.Nginx简介Nginx是一款高性能的http 服务器/反向代理服务器及电子邮件（IMAP/POP3）代理服务器。由俄罗斯的程序设计师Igor Sysoev所开发，官方测试nginx能够支支撑5万并发链接，并且cpu、内存等资源消耗却非常低，运行非常稳定 Nginx的主要应用1，Nginx可以用来做http服务器。Nginx可以独立提供http服务，可以做网页静态服务器2，Nginx可以用来做虚拟主机，实现在一台服务器虚拟出多个网站，例如个人网站使用的虚拟主机3，Nginx可以用来提供反向代理，负载均衡功能。当网站的访问量达到一定程度后，单台服务器不能满足用户的请求时，需要用多台服务器集群可以使用Nginx做反向代理。并且多台服务器可以平均分担负载，不会因为某台服务器负载高宕机而某台服务器闲置的情况 二.Nginx实现反向代理2.1 反向代理的含义常见的服务器一般采用正向代理的方式，如下图所示： 通常的代理服务器，只用于代理内部网络对Internet的连接请求，客户机必须指定代理服务器,并将本来要直接发送到Web服务器上的http请求发送到代理服务器中。由于外部网络上的主机并不会配置并使用这个代理服务器，普通代理服务器也被设计为在Internet上搜寻多个不确定的服务器,而不是针对Internet上多个客户机的请求访问某一个固定的服务器，因此普通的Web代理服务器不支持外部对内部网络的访问请求 当一个代理服务器能够代理外部网络上的主机（如Nginx），访问内部网络时，这种代理服务的方式称为反向代理服务。此时代理服务器对外就表现为一个Web服务器，外部网络就可以简单把它当作一个标准的Web服务器而不需要特定的配置。不同之处在于，这个服务器没有保存任何网页的真实数据，所有的静态网页或者CGI程序，都保存在内部的Web服务器上 反向代理的实现方式如下图所示： 2.2 简单模拟一个反向代理的实现反向代理模拟：两个域名指向同一台nginx服务器，用户访问不同的域名显示不同的网页内容。两个域名是www.sian.com.cn和www.sohu.comnginx服务器使用虚拟机192.168.101.3 实现方式：第一步：安装两个tomcat，分别运行在8080和8081端口。第二步：启动两个tomcat。第三步：反向代理服务器的配置 1234567891011121314151617181920212223242526272829303132upstream tomcat1 &#123; server 192.168.25.148:8080; &#125; server &#123; listen 80; server_name www.sina.com.cn; #charset koi8-r; #access_log logs/host.access.log main; location / &#123; proxy_pass http://tomcat1; index index.html index.htm; &#125; &#125; upstream tomcat2 &#123; server 192.168.25.148:8081; &#125; server &#123; listen 80; server_name www.sohu.com; #charset koi8-r; #access_log logs/host.access.log main; location / &#123; proxy_pass http://tomcat2; index index.html index.htm; &#125; &#125; 第四步：nginx重新加载配置文件第五步：配置域名在hosts文件中添加域名和ip的映射关系 12192.168.25.148 www.sina.com.cn192.168.25.148 www.sohu.com 三.Nginx实现负载均衡3.1 Nginx实现负载均衡的基本原理如果一个服务由多条服务器提供，需要把负载分配到不同的服务器处理，需要负载均衡处理Nginx配置文件：1234upstream tomcat2 &#123;server 192.168.25.148:8081;server 192.168.25.148:8082;&#125; 可以根据服务器的实际情况调整服务器权重。权重越高分配的请求越多，权重越低，请求越少。默认是都是1 1234upstream tomcat2 &#123;server 192.168.25.148:8081;server 192.168.25.148:8082 weight=2;&#125; 3.2 Nginx实现负载均衡的具体方法具体方案Nginx作为负载均衡器，所有请求都到了Nginx，可见Nginx处于非常重点的位置，如果Nginx服务器宕机后端web服务将无法提供服务，影响严重。为了屏蔽负载均衡服务器的宕机，需要建立一个备份机。主服务器和备份机上都运行高可用（High Availability）监控程序，通过传送诸如“I am alive”这样的信息来监控对方的运行状况。当备份机不能在一定的时间内收到这样的信息时，它就接管主服务器的服务IP并继续提供负载均衡服务；当备份管理器又从主管理器收到“I am alive”这样的信息时，它就释放服务IP地址，这样的主服务器就开始再次提供负载均衡服务。 keepalivedkeepalived简介keepalived是集群管理中保证集群高可用的一个服务软件，用来防止单点故障。 Keepalived的作用是检测web服务器的状态，如果有一台web服务器死机，或工作出现故障，Keepalived将检测到，并将有故障的web服务器从系统中剔除，当web服务器工作正常后Keepalived自动将web服务器加入到服务器群中，这些工作全部自动完成，不需要人工干涉，需要人工做的只是修复故障的web服务器。 keepalived工作原理keepalived是以VRRP协议为实现基础的，VRRP全称Virtual Router Redundancy Protocol，即虚拟路由冗余协议。虚拟路由冗余协议，可以认为是实现路由器高可用的协议，即将N台提供相同功能的路由器组成一个路由器组，这个组里面有一个master和多个backup，master上面有一个对外提供服务的vip（VIP = Virtual IP Address，虚拟IP地址，该路由器所在局域网内其他机器的默认路由为该vip），master会发组播，当backup收不到VRRP包时就认为master宕掉了，这时就需要根据VRRP的优先级来选举一个backup当master。这样的话就可以保证路由器的高可用了。keepalived主要有三个模块，分别是core、check和VRRP。core模块为keepalived的核心，负责主进程的启动、维护以及全局配置文件的加载和解析。check负责健康检查，包括常见的各种检查方式。VRRP模块是来实现VRRP协议的。 负载均衡示意图正常工作时： 发生主机宕机等意外情况时： 主机故障排除后：]]></content>
      <categories>
        <category>Nginx服务器</category>
      </categories>
      <tags>
        <tag>服务器</tag>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux系统Tomcat无法正常启动]]></title>
    <url>%2F2018%2F04%2F13%2FCentOS7.3%E7%B3%BB%E7%BB%9FTomcat%E6%97%A0%E6%B3%95%E6%AD%A3%E5%B8%B8%E5%90%AF%E5%8A%A8%E8%A7%A3%E5%86%B3%EF%BC%888005%E7%AB%AF%E5%8F%A3%E4%B8%8D%E8%83%BD%E5%90%AF%E5%8A%A8%EF%BC%89%2F</url>
    <content type="text"><![CDATA[我今天在阿里云买了一个服务器，使用CentOS7系统，在安装Tomcat是遇到错误排查了很长时间，在这里将错误总结记叙一下Linux系统CentOS7.3版中启动Tomcat7，确定JDK正常运行且配置正确的情况下，启动Tomcat始终无法正常访问 排错过程：第一步：关闭Tomcat，使用端口查看命令netstat -tunlp查看 发现8080端口，8009端口，8005端口均为被占用 第二步：启动Tomcat，使用端口查看命令netstat -tunlp查看，发现8080端口，8009端口正常启动，没有发现8005端口，使用netstat -tunlp|grep 8005命令查看，确定8005端口没有被占用，所以一定是8005端口是没有正常启动 解决办法：需要修改文件：$JAVA_HOME/jre/lib/security/java.security中的配置使用vi编辑器打开文件 将：securerandom.source=file:/dev/random改为： securerandom.source=file:/dev/urandom 注：可以使用/securerandom.source查找，n表示下一目标位置 重启Tomcat，发现3个端口均正常启动]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Tomcat</tag>
        <tag>Linux</tag>
        <tag>CentOS7</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bootstrap前端框架]]></title>
    <url>%2F2018%2F04%2F11%2FBootstrap%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6%2F</url>
    <content type="text"><![CDATA[Bootstrap框架的介绍及简单使用 一.BootStrap简介Bootstrap，来自 Twitter，是目前很受欢迎的前端框架。Bootstrap 是基于 HTML、CSS、JavaScript 的CSS/HTML框架，它简洁灵活，使得 Web 开发更加快捷。Bootstrap提供了优雅的HTML和CSS规范，由动态CSS语言Less写成Bootstrap预定义一套CSS样式和与样式相对应的JQuery代码，开发者只需要提供固定的HTML结构，添加固定的class样式，就可以完成指定效果的实现Bootstrap非常好的实现了响应式布局（解决移动互联网浏览提供的一种方案），使一个网站能兼容多个终端（手机，iPad等），使用Bootstrap制作的网站不用制定多个版本，也能为不同终端的用户提供很好的用户体验 二.BootStrap入门Bootstrap的官方网站上有非常详细的教程，给出了很多实例和模板，想使用Bootstrap只需要看Bootstrap官网上的教程即可Bootstrap官网链接 打开官网 点击页面中央的中文文档，打开教程页 教程页的导航栏中将Bootstrap的教程分为了几个部分，前4个部分的内容即可让不懂Bootstrap初学者能够简单使用Bootstrap第1部分起步讲的是Bootstrap的下载，安装（导入到项目中），及环境的配置。第2，3，4部分则是用具体的Demo对Bootstrap的各种样式和效果的列举展示，每个Demo都有相应的代码，使用者只需要将需要的代码粘贴到自己的项目中然后做相应的修改即可 三.BootStrap导入项目及环境配置3.1 Bootstrap下载在起步部分，可以看到BootStrap的下载选项 如果只是使用该框架的话，选择第一项编译完成，不包含源码及文件的Bootstrap即可 下载完成后得到一个名称中带有dist的文件夹 版本不同名称可能不同，我下载的是3.3.7版本，此文件的目录结构下如图，css文件夹下放置的是Bootstrap的样式文件，js文件夹下放置的是Bootstrap的核心文件，fonts文件夹下则是和字体相关的文件 12345678910111213141516171819bootstrap/├── css/│ ├── bootstrap.css│ ├── bootstrap.css.map│ ├── bootstrap.min.css│ ├── bootstrap.min.css.map│ ├── bootstrap-theme.css│ ├── bootstrap-theme.css.map│ ├── bootstrap-theme.min.css│ └── bootstrap-theme.min.css.map├── js/│ ├── bootstrap.js│ └── bootstrap.min.js└── fonts/ ├── glyphicons-halflings-regular.eot ├── glyphicons-halflings-regular.svg ├── glyphicons-halflings-regular.ttf ├── glyphicons-halflings-regular.woff └── glyphicons-halflings-regular.woff2 3.2 搭建Bootstrap环境将以上3个文件夹和其中的文件放置到wabapp目录下。因为Bootstrap中运用了很多JQuery插件的内容，所以Bootstrap正常使用必须还要导入JQuery的核心文件（版本不能老，否则Bootstrap某些功能不能正常使用） 3.3 在页面文件中进行Bootstrap的基本设置在Bootstrap官网教程的起步部分，给出了Bootstrap的模板： 12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt; &lt;!-- 上述3个meta标签*必须*放在最前面，任何其他内容都*必须*跟随其后！ --&gt; &lt;title&gt;Bootstrap 101 Template&lt;/title&gt; &lt;!-- Bootstrap --&gt; &lt;link href=&quot;css/bootstrap.min.css&quot; rel=&quot;stylesheet&quot;&gt; &lt;!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries --&gt; &lt;!-- WARNING: Respond.js doesn&apos;t work if you view the page via file:// --&gt; &lt;!--[if lt IE 9]&gt; &lt;script src=&quot;https://cdn.bootcss.com/html5shiv/3.7.3/html5shiv.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://cdn.bootcss.com/respond.js/1.4.2/respond.min.js&quot;&gt;&lt;/script&gt; &lt;![endif]--&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;你好，世界！&lt;/h1&gt; &lt;!-- jQuery (necessary for Bootstrap&apos;s JavaScript plugins) --&gt; &lt;script src=&quot;https://cdn.bootcss.com/jquery/1.12.4/jquery.min.js&quot;&gt;&lt;/script&gt; &lt;!-- Include all compiled plugins (below), or include individual files as needed --&gt; &lt;script src=&quot;js/bootstrap.min.js&quot;&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 模板中需要注意的几点：1）媒体设置，三个&lt; meta &gt;标签，是Bootstrap进行响应式开发必须要有的设置 123&lt;meta charset=&quot;utf-8&quot;&gt;&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt; 2）导入Bootstrap的支持文件，包括Bootstrap的样式文件，JQuery核心文件和Bootstrap的核心文件（此模板中的文件路径使用的是网络路径，可以根据使用情况改为本地路径） 123&lt;link href=&quot;css/bootstrap.min.css&quot; rel=&quot;stylesheet&quot;&gt;&lt;script src=&quot;https://cdn.bootcss.com/jquery/1.12.4/jquery.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;js/bootstrap.min.js&quot;&gt;&lt;/script&gt; 3.4 响应式布局相关的设置Bootstrap在3个&lt; meta &gt; 标签中设置和响应式布局相关的内容1&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt; 其中name=”viewport”的标签中的设置比较重要viewport指的是设备的屏幕上用来显示网页的区域content的设置参数： 属性名 属性描述 举例 width 设置layout viewport的宽度，可以是一个正整数，也可以是字符串”width-device”(即根据设备宽度自动缩放) width=800px或width=device-width(常用) initial-scale 设置页面的初始缩放值，为一个数字，可以带小数 initial-scale=1(1表示按1:1缩放) minimum-scale 允许用户的最小缩放值，为一个数字，可以带小数 minimum-scale=0.5 maximum-scale 允许用户的最大缩放值，为一个数字，可以带小数 maximum-scale=1.5 height 设置layout viewport的高度，这个属性并不重要，很少使用 user-scalable 是否允许用户进行缩放，值为”no”或”yes”, no代表不允许,yes代表允许 user-scalable=yes(如果选no上面的设置全废了) 四.Bootstrap导学由于Bootstrap的官网给了非常详细的教程，下面根据教程做几个示例示范一下如何使用该教程Bootstrap，如果需要使用Bootstrap，直接看官网教程即可 4.1 分页条黑马商城商品分类分页展示部分，未使用Bootstrap时的效果： JSP代码： 123456789101112131415161718192021222324252627282930&lt;div id=&quot;paginationId&quot; style=&quot;font-size:14px;margin:0;display:block;&quot;&gt; 第$&#123;pageBean.pageNumber&#125;/$&#123;pageBean.totalPage&#125;页&amp;nbsp; 总项数:$&#123;pageBean.totalRecord&#125;&amp;nbsp; 每页显示:$&#123;pageBean.pageSize&#125;&amp;nbsp; &lt;c:if test=&quot;$&#123;pageBean.pageNumber gt 1&#125;&quot;&gt; &lt;a href=&quot;$&#123;pageContext.request.contextPath&#125;/productServlet?method=productList&amp;cid=$&#123;pageBean.data[0].cid&#125;&amp;pageNumber=1&quot;&gt;[首页] &lt;/a&gt;&amp;nbsp; &lt;a href=&quot;$&#123;pageContext.request.contextPath&#125;/productServlet?method=productList&amp;cid=$&#123;pageBean.data[0].cid&#125;&amp;pageNumber=$&#123;pageBean.pageNumber-1&#125;&quot;&gt; [上一页]&lt;/a&gt; &lt;/c:if&gt;&amp;nbsp; &lt;c:forEach var=&quot;i&quot; begin=&quot;1&quot; end=&quot;$&#123;pageBean.totalPage&#125;&quot;&gt; &lt;c:if test=&quot;$&#123;pageBean.pageNumber eq i&#125;&quot;&gt; 第$&#123;i&#125;页 &lt;/c:if&gt; &lt;c:if test=&quot;$&#123;pageBean.pageNumber != i&#125;&quot;&gt; &lt;a href=&quot;$&#123;pageContext.request.contextPath&#125;/productServlet?method=productList&amp;cid=$&#123;pageBean.data[0].cid&#125;&amp;pageNumber=$&#123;i&#125;&quot;&gt;第$&#123;i&#125;页&lt;/a&gt; &lt;/c:if&gt; &lt;/c:forEach&gt;&amp;nbsp; &lt;c:if test=&quot;$&#123;pageBean.pageNumber lt pageBean.totalPage&#125;&quot;&gt; &lt;a href=&quot;$&#123;pageContext.request.contextPath&#125;/productServlet?method=productList&amp;cid=$&#123;pageBean.data[0].cid&#125;&amp;pageNumber=$&#123;pageBean.pageNumber+1&#125;&quot;&gt;[下一页] &lt;/a&gt;&amp;nbsp; &lt;a href=&quot;$&#123;pageContext.request.contextPath&#125;/productServlet?method=productList&amp;cid=$&#123;pageBean.data[0].cid&#125;&amp;pageNumber=$&#123;pageBean.totalPage&#125;&quot;&gt; [尾页]&lt;/a&gt; &lt;/c:if&gt; &lt;/div&gt; 查看Bootstrap官方教程，1.在导航栏中选择组件部分 2.根据右侧内容提纲找到分页部分，3.复制默认分页代码 在默认效果上进行更改及添加，完善后的代码： 123456789101112131415161718192021222324252627282930313233343536373839&lt;nav aria-label=&quot;Page navigation&quot;&gt; &lt;ul class=&quot;pagination&quot;&gt; &lt;c:if test=&quot;$&#123;!(pageBean.pageNumber gt 1)&#125;&quot;&gt; &lt;li class=&quot;disabled&quot;&gt; &lt;span aria-hidden=&quot;true&quot;&gt;&amp;laquo;&lt;/span&gt; &lt;/li&gt; &lt;/c:if&gt; &lt;c:if test=&quot;$&#123;pageBean.pageNumber gt 1&#125;&quot;&gt; &lt;li&gt; &lt;a href=&quot;$&#123;pageContext.request.contextPath&#125;/productServlet?method=productList&amp;cid=$&#123;pageBean.data[0].cid&#125;&amp;pageNumber=$&#123;pageBean.pageNumber-1&#125;&quot; aria-label=&quot;Previous&quot;&gt; &lt;span aria-hidden=&quot;true&quot;&gt;&amp;laquo;&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &lt;/c:if&gt; &lt;c:forEach var=&quot;i&quot; begin=&quot;1&quot; end=&quot;$&#123;pageBean.totalPage&#125;&quot;&gt; &lt;c:if test=&quot;$&#123;pageBean.pageNumber eq i&#125;&quot;&gt; &lt;%--&lt;li class=&quot;active&quot;&gt;&lt;a href=&quot;#&quot;&gt;$&#123;i&#125;&lt;/a&gt;&lt;/li&gt;--%&gt; &lt;li class=&quot;active&quot;&gt;&lt;a href=&quot;#&quot;&gt;$&#123;i&#125;&lt;/a&gt;&lt;/li&gt; &lt;/c:if&gt; &lt;c:if test=&quot;$&#123;pageBean.pageNumber != i&#125;&quot;&gt; &lt;li&gt;&lt;a href=&quot;$&#123;pageContext.request.contextPath&#125;/productServlet?method=productList&amp;cid=$&#123;pageBean.data[0].cid&#125;&amp;pageNumber=$&#123;i&#125;&quot;&gt;$&#123;i&#125;&lt;/a&gt;&lt;/li&gt; &lt;/c:if&gt; &lt;/c:forEach&gt; &lt;c:if test=&quot;$&#123;pageBean.pageNumber lt pageBean.totalPage&#125;&quot;&gt; &lt;li&gt; &lt;a href=&quot;$&#123;pageContext.request.contextPath&#125;/productServlet?method=productList&amp;cid=$&#123;pageBean.data[0].cid&#125;&amp;pageNumber=$&#123;pageBean.pageNumber+1&#125;&quot; aria-label=&quot;Next&quot;&gt; &lt;span aria-hidden=&quot;true&quot;&gt;&amp;raquo;&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &lt;/c:if&gt; &lt;c:if test=&quot;$&#123; !(pageBean.pageNumber lt pageBean.totalPage)&#125;&quot;&gt; &lt;li class=&quot;disabled&quot;&gt; &lt;span aria-hidden=&quot;true&quot;&gt;&amp;raquo;&lt;/span&gt; &lt;/li&gt; &lt;/c:if&gt; &lt;/ul&gt; &lt;/nav&gt; 加入Bootstrap样式后的分页栏效果：]]></content>
      <categories>
        <category>前端</category>
        <category>Bootstrap</category>
      </categories>
      <tags>
        <tag>Bootstrap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maven-01-私服搭建及使用]]></title>
    <url>%2F2018%2F04%2F07%2FMaven-01-%E7%A7%81%E6%9C%8D%E6%90%AD%E5%BB%BA%E5%8F%8A%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[Maven私服的概念，私服搭建及使用 一.Maven私服简介Maven私服是Maven仓库的一种，Maven仓库有三种，分别是本地仓库，远程仓库（私服），中央仓库。Maven私服一般都是由公司或团体为方便内部使用而搭建的，一般部署在局域网中，所以在局域网中使用私服下载jar包的速度比中央仓库方便。而且公司或组织的不方便公开的项目部署在私服中也比较安全。正因为这些优点，私服在企业中的应用非常广泛 二.Maven私服搭建##2.1 下载nexus从官网下载nexus的最新版本，nexus是用Java语言开发的用来搭建Maven私服的一款BS结构的软件，即nexus是通过浏览器来管理jar包的如果官网下载速度过慢，也可以在CSDN上下载nexus下载解压nexus的压缩包，其内容如下，我是用的是nexus的2.12版本 如上图，进入nexus的bin目录下，使用管理员方式打开命令行，因为nexus在安全方面做了很多工作，所以安装使用必须要有管理员权限 2.2 运行命令安装软件并开启服务nexus.bat install命令安装nexusnexus.bat start命令开启nexus服务 2.3 使用浏览器访问nexus打开浏览器，输入地址http://localhost:8081/nexus/ （nexus的默认端口是8081），登录nexus，点击右上角的login（nexus有一个默认管理员：用户名admin，密码admin123），登录成功后如下图所示，即Maven私服的管理界面 三.Maven私服使用3.1 将Maven项目打包并上传到到Maven私服3.1.1 修改Maven配置文件在Maven的配置文件setting.xml中配置管理员用户名和密码。在&lt;servers&gt;标签下添加如下配置：12345678910&lt;server&gt; &lt;id&gt;releases&lt;/id&gt; &lt;username&gt;admin&lt;/username&gt; &lt;password&gt;admin123&lt;/password&gt;&lt;/server&gt;&lt;server&gt; &lt;id&gt;snapshots&lt;/id&gt; &lt;username&gt;admin&lt;/username&gt; &lt;password&gt;admin123&lt;/password&gt;&lt;/server&gt; 3.1.2 修改项目配置文件pom.xml添加Maven私服的相关信息 12345678910 &lt;distributionManagement&gt; &lt;repository&gt; &lt;id&gt;releases&lt;/id&gt;&lt;url&gt;http://localhost:8081/nexus/content/repositories/releases/&lt;/url&gt; &lt;/repository&gt; &lt;snapshotRepository&gt; &lt;id&gt;snapshots&lt;/id&gt;&lt;url&gt;http://localhost:8081/nexus/content/repositories/snapshots/&lt;/url&gt; &lt;/snapshotRepository&gt; &lt;/distributionManagement&gt; 3.1.3 发布项目到私服只用执行Maven命令deploy即可完成项目的打包和发布等一系列动作 3.2 从Maven私服下载jar包如何从Maven私服自动下载所需的依赖文件呢？需要进行一些配置 修改Maven配置文件在Maven的配置文件setting.xml中配置Maven私服的相关信息在&lt;profile&gt;标签下添加如下配置： 123456789101112131415161718192021222324252627282930313233&lt;profile&gt; &lt;!--profile的id--&gt; &lt;id&gt;dev&lt;/id&gt; &lt;repositories&gt; &lt;repository&gt; &lt;!--仓库id，repositories可以配置多个仓库，保证id不重复--&gt; &lt;id&gt;nexus&lt;/id&gt; &lt;!--仓库地址，即nexus仓库组的地址--&gt; &lt;url&gt;http://localhost:8081/nexus/content/groups/public/&lt;/url&gt; &lt;!--是否下载releases构件--&gt; &lt;releases&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/releases&gt; &lt;!--是否下载snapshots构件--&gt; &lt;snapshots&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/repository&gt; &lt;/repositories&gt; &lt;pluginRepositories&gt; &lt;!-- 插件仓库，maven的运行依赖插件，也需要从私服下载插件 --&gt; &lt;pluginRepository&gt; &lt;!-- 插件仓库的id不允许重复，如果重复后边配置会覆盖前边 --&gt; &lt;id&gt;public&lt;/id&gt; &lt;name&gt;Public Repositories&lt;/name&gt; &lt;url&gt;http://localhost:8081/nexus/content/groups/public/&lt;/url&gt; &lt;/pluginRepository&gt; &lt;/pluginRepositories&gt; &lt;/profile&gt; &lt;activeProfiles&gt; &lt;activeProfile&gt;dev&lt;/activeProfile&gt;&lt;/activeProfiles&gt;]]></content>
      <categories>
        <category>Maven</category>
        <category>私服搭建</category>
      </categories>
      <tags>
        <tag>Maven私服</tag>
        <tag>服务器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery-zTree插件使用]]></title>
    <url>%2F2018%2F04%2F02%2FjQuery-zTree%E6%8F%92%E4%BB%B6%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[在页面中使用zTree插件添加菜单栏功能 一.zTree插件入门1.zTree简介ZTree 是一个依靠 jQuery 实现的多功能 “树插件”。优异的性能、灵活的配置、多种功能的组合是 ZTree 最大优点。 2.zTree插件的核心文件ztree官网：在地址栏中输入ztree.me ztree官网可以查看在线API，也可以下载最新的ztree插件包（放置在码云上） 下载ztree插件包，目录结构如下，其中api文件夹下是ztree插件的离线API文档，css文件夹下是ztree插件的样式文件，demo文件夹下有ztree插件实现的效果的展示，js文件夹下是ztree插件的核心文件 打开js文件夹，发现其中有一个jquery的核心文件，说明ztree的使用需要jquery核心的支持。其他10个文件则是ztree的核心文件，这10文件实际上是5个文件，因为每个文件都有一个完整版和一个简洁版（名称中带有.min），简洁版是在完整版的基础上去掉所有空格和换行，为节省空间而创建的，两者代码仍是相同的。 3.zTree插件的API API的主要内容：1.zTree的方法树的构造，销毁，获取等方法 2.setting 配置用于ztree树的相关配置信息 3.treeNode 节点数据的属性构成树的数据的信息和配置 二.构造一个zTree树1.zTree树的构造方法使用ZTreeAPI中的$.fn.zTree对象的init()方法第一个参数是树对象的id，第二个参数是树对象的配置（参考API文档的setting配置），第三个参数是树对象的数据（参考API文档的treeNode节点数据属性），其是一个json格式的数据 2.zTree树的节点数据格式###1.标准json数据格式 setting配置采用默认配置，zNodes节点数据采用标准json数据格式，例如： zNodes节点数据对象：1234567//每个json对象表示一个节点数据&#123;&quot;name&quot;:&quot;节点一&quot;,&quot;children&quot;:[ &#123;&quot;name&quot;:&quot;节点一_1&quot;&#125;, &#123;&quot;name&quot;:&quot;节点一_2&quot;&#125; ]&#125;,&#123;&quot;name&quot;:&quot;节点二&quot;&#125;,&#123;&quot;name&quot;:&quot;节点三&quot;&#125; 效果： 总结：使用标准json数据格式构造zTree树时数据组织非常麻烦，zTree提供了更为简单的数据格式取代了标准json数据格式 ###2.使用简单json数据构造zTree 步骤1.在setting中设置使用简单数据格式 1234567891011var setting = &#123; data : &#123; // 设置是否启用简单数据 simpleData : &#123; enable : true &#125; &#125;, callback : &#123; onClick : onClick &#125; &#125; 步骤二.zNodes节点数据对象123&#123;&quot;id&quot;:&quot;1&quot;,&quot;pId&quot;:&quot;2&quot;,&quot;name&quot;:&quot;节点一&quot;&#125;,&#123;&quot;id&quot;:&quot;2&quot;,&quot;pId&quot;:&quot;3&quot;,&quot;name&quot;:&quot;节点二&quot;&#125;,&#123;&quot;id&quot;:&quot;3&quot;,&quot;pId&quot;:&quot;0&quot;,&quot;name&quot;:&quot;节点三&quot;&#125; 效果： 简单数据格式构建zNodes节点：每个节点数据都有一个独立的id，若A节点的pid和B节点的id对应，那么A节点就是B节点的子节点，若一个节点数据的pid没有和它相对应的id，那么这个节点数据就是根节点总结：简单数据格式清晰易懂，适合节点数据较多较复杂的场景，实际应用中一般采用这种方式 三.zTree插件实战 目标：实现如上图所示的zTree树 1.导入zTree的核心及支持类库zTree插件的核心文件放路径根据实际情况修改12345678910111213&lt;!-- 导入jquery核心类库 --&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;$&#123;pageContext.request.contextPath &#125;/js/jquery-1.8.3.js&quot;&gt;&lt;/script&gt;&lt;!-- 导入ztree类库 --&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;$&#123;pageContext.request.contextPath &#125;/js/ztree/zTreeStyle.css&quot; type=&quot;text/css&quot; /&gt;&lt;script src=&quot;$&#123;pageContext.request.contextPath &#125;/js/ztree/jquery.ztree.all-3.5.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;&lt;script src=&quot;$&#123;pageContext.request.contextPath &#125;/js/easyui/locale/easyui-lang-zh_CN.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt; 2.在页面部分创建zTree对象页面代码1234567891011&lt;div data-options=&quot;region:&apos;west&apos;,split:true,title:&apos;菜单导航&apos;&quot; style=&quot;width:200px&quot;&gt; &lt;div class=&quot;easyui-accordion&quot; fit=&quot;true&quot; border=&quot;false&quot;&gt; &lt;div title=&quot;基本功能&quot; data-options=&quot;iconCls:&apos;icon-mini-add&apos;&quot; style=&quot;overflow:auto&quot;&gt; &lt;ul id=&quot;treeMenu&quot; class=&quot;ztree&quot;&gt;&lt;/ul&gt; &lt;/div&gt; &lt;div title=&quot;系统管理&quot; data-options=&quot;iconCls:&apos;icon-mini-add&apos;&quot; style=&quot;overflow:auto&quot;&gt; &lt;ul id=&quot;adminMenu&quot; class=&quot;ztree&quot;&gt;&lt;/ul&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; accordion面板中定义两个选项，每个选项中定义一个ul行内标签，设置标签class属性为ztree类型 3.使用zTree提供的API为节点绑定事件，完成zTree树的加载定义upload函数，在页面加载完毕后执行，1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// 初始化ztree菜单 $(function() &#123; //1.创建setting对象配置zTree树 var setting = &#123; data : &#123; // 采用简单数据格式 simpleData : &#123; enable : true &#125; &#125;, callback : &#123; onClick : onClick &#125; &#125;; // 2.基本功能菜单加载 $.ajax(&#123; //通过url路径下的静态资源（json格式的数据）构建zNodes节点数据 url : &apos;$&#123;pageContext.request.contextPath&#125;/json/menu.json&apos;, type : &apos;POST&apos;, dataType : &apos;text&apos;, success : function(data) &#123; //创建zNodes对象 var zNodes = eval(&quot;(&quot; + data + &quot;)&quot;); //3.调用init()方法完成zTree树的加载 $.fn.zTree.init($(&quot;#treeMenu&quot;), setting, zNodes); &#125;, error : function(msg) &#123; alert(&apos;菜单加载异常!&apos;); &#125; &#125;); // 系统管理菜单加载 $.ajax(&#123; url : &apos;$&#123;pageContext.request.contextPath&#125;/json/admin.json&apos;, type : &apos;POST&apos;, dataType : &apos;text&apos;, success : function(data) &#123; var zNodes = eval(&quot;(&quot; + data + &quot;)&quot;); $.fn.zTree.init($(&quot;#adminMenu&quot;), setting, zNodes); &#125;, error : function(msg) &#123; alert(&apos;菜单加载异常!&apos;); &#125; &#125;); &#125; 项目中的menu.json文件中的内容 1234567891011121314[ &#123; &quot;id&quot;:&quot;11&quot;, &quot;pId&quot;:&quot;0&quot;, &quot;name&quot;:&quot;基础数据&quot;&#125;, &#123; &quot;id&quot;:&quot;112&quot;, &quot;pId&quot;:&quot;11&quot;, &quot;name&quot;:&quot;取派员设置&quot;, &quot;page&quot;:&quot;page_base_staff.action&quot;&#125;, &#123; &quot;id&quot;:&quot;113&quot;, &quot;pId&quot;:&quot;11&quot;, &quot;name&quot;:&quot;区域设置&quot;,&quot;page&quot;:&quot;page_base_region.action&quot;&#125;, &#123; &quot;id&quot;:&quot;114&quot;, &quot;pId&quot;:&quot;11&quot;, &quot;name&quot;:&quot;管理分区&quot;, &quot;page&quot;:&quot;page_base_subarea.action&quot;&#125;, &#123; &quot;id&quot;:&quot;115&quot;, &quot;pId&quot;:&quot;11&quot;, &quot;name&quot;:&quot;管理定区/调度排班&quot;,&quot;page&quot;:&quot;page_base_decidedzone.action&quot;&#125;, &#123; &quot;id&quot;:&quot;12&quot;, &quot;pId&quot;:&quot;0&quot;, &quot;name&quot;:&quot;受理&quot;&#125;, &#123; &quot;id&quot;:&quot;121&quot;, &quot;pId&quot;:&quot;12&quot;, &quot;name&quot;:&quot;业务受理&quot; ,&quot;page&quot;:&quot;page_qupai_noticebill_add.action&quot;&#125;, &#123; &quot;id&quot;:&quot;122&quot;, &quot;pId&quot;:&quot;12&quot;, &quot;name&quot;:&quot;工作单快速录入&quot; ,&quot;page&quot;:&quot;page_qupai_quickworkorder.action&quot;&#125;, &#123; &quot;id&quot;:&quot;124&quot;, &quot;pId&quot;:&quot;12&quot;, &quot;name&quot;:&quot;工作单导入&quot; ,&quot;page&quot;:&quot;page_qupai_workorderimport.action&quot;&#125;, &#123; &quot;id&quot;:&quot;13&quot;, &quot;pId&quot;:&quot;0&quot;, &quot;name&quot;:&quot;调度&quot;&#125;, &#123; &quot;id&quot;:&quot;131&quot;, &quot;pId&quot;:&quot;13&quot;, &quot;name&quot;:&quot;查台转单&quot;,&quot;page&quot;:&quot;&quot;&#125;, &#123; &quot;id&quot;:&quot;132&quot;, &quot;pId&quot;:&quot;13&quot;, &quot;name&quot;:&quot;人工调度&quot;,&quot;page&quot;:&quot;page_qupai_diaodu.action&quot;&#125;] 项目中的admin.json文件中的内容12345[ &#123; &quot;id&quot;:&quot;1001&quot;, &quot;pId&quot;:&quot;100&quot;, &quot;name&quot;:&quot;用户管理&quot;, &quot;page&quot;:&quot;page_admin_userlist.action&quot;&#125;, &#123; &quot;id&quot;:&quot;1002&quot;, &quot;pId&quot;:&quot;100&quot;, &quot;name&quot;:&quot;功能权限管理&quot;, &quot;page&quot;:&quot;page_admin_function.action&quot;&#125;, &#123; &quot;id&quot;:&quot;1003&quot;, &quot;pId&quot;:&quot;100&quot;, &quot;name&quot;:&quot;角色管理&quot;, &quot;page&quot;:&quot;page_admin_role.action&quot;&#125;]]]></content>
      <categories>
        <category>前端</category>
        <category>JQuery</category>
      </categories>
      <tags>
        <tag>ZTree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java设计模式--代理模式与JDK动态代理，cglib动态代理]]></title>
    <url>%2F2018%2F03%2F28%2FJava%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F--%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E4%B8%8EJDK%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%EF%BC%8Ccglib%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%2F</url>
    <content type="text"><![CDATA[代理模式在Java中的使用 一.代理模式的概念即Proxy Pattern，23种常用的面向对象软件的设计模式之一。 代理模式的定义：为其他对象提供一种代理以控制对这个对象的访问。在某些情况下，一个对象不适合或者不能直接引用另一个对象，因此创建代理对象，代理对象在客户端和目标对象之间起到中介的作用。 代理模式的组成部分：代理模式使用三个角色实现其目标功能，分别是：抽象角色（AbstractRole）：通过接口或抽象类声明真实角色实现的业务方法。代理角色（ProxyRole）：实现抽象角色，是真实角色的代理，通过真实角色的业务逻辑方法来实现抽象方法，并可以附加自己的操作。真实角色（RealRole）：实现抽象角色，定义真实角色所要实现的业务逻辑，供代理角色调用。 代理模式分类：代理模式根据其实现方法的不同分为动态代理和静态代理，静态代理和动态代理的主要区别在于其生成代理类的方式，静态代理由程序员直接编写代理类，而动态代理的代理类是在程序执行过程中生成的 二.静态代理静态代理根据代理类的生成方式分为聚合式静态代理和继承式静态代理聚合式静态代理中代理类和目标类都实现了同一个接口，又称为代理类聚合了目标类，可实现灵活多变继承式静态代理中代理类继承了目标类，减少了代码量（不必对不进行功能扩展的方法进行覆盖），但是不够灵活 2.1 聚合式静态代理示例：该程序由4部分组成： 接口：抽象角色（AbstractRole）1234public interface IUserDao &#123; void save(); void find();&#125; 目标类：即真实角色（RealRole）12345678910public class UserDao implements IUserDao&#123; @Override public void save() &#123; System.out.println(&quot;模拟： 保存用户！&quot;); &#125; @Override public void find() &#123; System.out.println(&quot;查询&quot;); &#125;&#125; 代理类：代理角色（ProxyRole）由程序员根据需要（扩展功能）编写12345678910111213141516public class UserDaoProxy implements IUserDao&#123; //代理对象，需要维护一个目标对象 private IUserDao target = new UserDao(); //代理对象对目标对象进行功能扩展，使得代理对象能够完成目标对象不能完成的任务 @Override public void save() &#123; System.out.println(&quot;代理操作： 开启事务...&quot;); target.save(); System.out.println(&quot;代理操作：提交事务...&quot;); &#125; //不需要进行功能扩展的方法则直接调用目标对象中对应的该方法 @Override public void find() &#123; target.find(); &#125;&#125; 测试方法：12345678public class Application &#123; public static void main(String[] args) &#123; //创建代理对象 IUserDao proxy = new UserDaoProxy(); proxy.find(); proxy.save(); &#125;&#125; 程序执行结果： 代理类UserDaoProxy扩展了目标类UserDao的功能，增强了save( )方法的功能，原本save( )方法只输出一句话，进行功能增强后多输出了两句话 2.1 继承式静态代理示例：该程序由3部分组成：不需要接口即抽象角色（AbstractRole） 目标类：即真实角色（RealRole）12345678910public class UserDao &#123; @Override public void save() &#123; System.out.println(&quot;模拟： 保存用户！&quot;); &#125; @Override public void find() &#123; System.out.println(&quot;查询&quot;); &#125;&#125; 代理类：代理角色（ProxyRole）由程序员编写123456789public class UserDaoProxy extends UserDao&#123; //代理对象对目标对象进行功能扩展 @Override public void save() &#123; System.out.println(&quot;代理操作： 开启事务...&quot;); target.save(); System.out.println(&quot;代理操作：提交事务...&quot;); &#125;&#125; 测试方法：12345678public class Application &#123; public static void main(String[] args) &#123; //创建代理对象 IUserDao proxy = new UserDaoProxy(); proxy.find(); proxy.save(); &#125;&#125; 继承式静态代理实现的功能和聚合式静态代理相同 三.动态态代理动态代理中的代理类是在程序执行过程中生成的，而不是由程序员直接编写的动态代理根据代理类生成方法的不同分为JDK动态代理和cglib动态代理，和静态代理中聚合式与继承式的分类相同，JDK动态代理中代理类和目标类都实现了同一个接口，cglib动态代理中代理类则继承了目标类 3.1 JDK动态代理JDK动态代理主要使用了反射技术，同时还要用到JavaSE中的Proxy类和InvocationHandler接口 3.1.1 动态代理涉及的类和接口1）Proxy类 Proxy类在reflect包下，与反射的关系紧密Proxy类中的方法： 其中第4个方法newProxyInstance( )最常用，用来创建代理类，其三个参数分别为（1）一个类加载器，（2）代理类和目标类共同实现的接口，（3）一个实现了InvocationHandler接口的对象 2）InvocationHandler接口InvocationHandler接口的主要用途就是作为Proxy类的newProxyInstance( )方法的参数，用来创建代理对象。其有4个实现类InvocationHandler接口只有一个invoke( )方法 3.1.2 动态代理示例：下面展示一个静态代理程序，和静态代理一样，由4部分组成： 接口：抽象角色（AbstractRole）12345//和静态代理一样，没有更改public interface IUserDao &#123; void save(); void find();&#125; 目标类：即真实角色（RealRole）1234567891011//和静态代理一样，没有更改public class UserDao implements IUserDao&#123; @Override public void save() &#123; System.out.println(&quot;模拟： 保存用户！&quot;); &#125; @Override public void find() &#123; System.out.println(&quot;查询&quot;); &#125;&#125; 代理类：代理角色（ProxyRole）动态代理中，代理类是由程序生成的，这时不直接编写代理类，而是编写一个专门生成代理类的工厂类ProxyFactory，由ProxyFactory根据传入的参数生成代理类ProxyFactory1234567891011121314151617181920212223242526272829303132333435363738394041424344public class ProxyFactory &#123; //构造方法，接收一个目标对象 private Object target; public ProxyFactory(Object target) &#123; this.target = target; &#125; //代理对象的创建方法 public Object getProxyInstance() &#123; //调用Proxy类的newProxyInstance()方法 Object proxy = Proxy.newProxyInstance( //参数一：目标对象使用的类加载器 target.getClass().getClassLoader(), //参数二：目标对象实现的所有接口 target.getClass().getInterfaces(), //参数三：一个InvocationHandler对象的实现类，这里使用适配器模式创建 //执行代理对象方法时才执行此方法，创建代理对象是不执行此方法 new InvocationHandler() &#123; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; //获取当前执行的方法的方法名 String methodName = method.getName(); //方法返回值 Object result = null; //判断程序调用的代理类的方法 if (&quot;find&quot;.equals(methodName)) &#123; //不需要进行功能扩展的方法，反射创建目标类的方法并调用 result = method.invoke(target, args); &#125; //需要进行功能扩展的方法 else &#123; //进行功能扩展 System.out.println(&quot;开启事务...&quot;); //反射创建目标类的方法并调用 result = method.invoke(target, args); System.out.println(&quot;提交事务...&quot;); &#125; //返回结果 return result; &#125; &#125; ); return proxy; &#125;&#125; 测试方法：12345678910111213public class Application &#123; public static void main(String[] args) &#123; //创建目标对象 IUserDao target = new UserDao(); System.out.println(&quot;目标对象：&quot; + target.getClass()); // class cn.itcast.b_dynamic.UserDao //创建代理对象，使用代理工厂 IUserDao proxy = (IUserDao) new ProxyFactory(target).getProxyInstance(); System.out.println(&quot;代理对象： &quot; + proxy.getClass()); // class $Proxy0 //执行代理对象的方法 proxy.find(); proxy.save(); &#125;&#125; 程序执行结果： 3.2 cglib动态代理JDK的动态代理有一个限制，就是使用动态代理的对象必须实现一个或多个接口。如果想代理没有实现接口的类，就需要使用cglib实现cglib是一个强大的，高性能，高质量的code生成类库，它可以在运行期通过生成代理对象的方式扩展目标类的功能，它广泛的被许多AOP的框架使用，例如Spring AOP和dynaop，为他们提供方法的interception（拦截）cglib包的底层是通过使用一个小而快的字节码处理框架ASM，来转换字节码并生成新的类。不鼓励直接使用ASM，因为它要求你必须对JVM内部结构包括class文件的格式和指令集都很熟悉 目标类：即真实角色（RealRole）12345678public class UserDao &#123; public static void save() &#123; System.out.println(&quot;模拟： 保存用户！&quot;); &#125; public void find() &#123; System.out.println(&quot;查询&quot;); &#125;&#125; 代理类：代理角色（ProxyRole）123456789101112131415161718192021222324252627public class ProxyFactory implements MethodInterceptor&#123; //接收一个目标对象 private Object target; public ProxyFactory(Object target) &#123; this.target = target; &#125; //返回代理对象——一个目标对象的子类对象 public Object getProxyInstance() &#123; //字节码生成工具类 Enhancer en = new Enhancer(); //设置父类 en.setSuperclass(target.getClass()); //设置回调函数 en.setCallback(this); //创建子类对象 return en.create(); &#125; // 事件处理器，执行目标方法时候执行 @Override public Object intercept(Object obj, Method method, Object[] args, MethodProxy methodProxy) throws Throwable &#123; System.out.println(&quot;开启事务...&quot;); Object result = method.invoke(target, args); System.out.println(&quot;提交事务...&quot;); return result; &#125;&#125; 测试方法：12345678910111213public class App &#123; public static void main(String[] args) &#123; //创建目标对象 UserDao target = new UserDao(); System.out.println(&quot;目标对象：&quot; + target.getClass()); //创建代理对象 UserDao proxy = (UserDao) new ProxyFactory(target).getProxyInstance(); System.out.println(&quot;代理对象： &quot; + proxy.getClass()); //执行代理对象的方法 proxy.find(); proxy.save(); &#125;&#125; #总结：经过静态代理和动态代理实现方法的分析，可以看出动态代理的优势：如果对多个目标类进行同样的功能扩展，使用静态代理需要为每个目标类创建一个代理对象，耦合性非常高，可复用性非常低，而使用动态代理，则只需要创建一个代理工厂，代理对象可以用代理工厂创建，这样扩展功能只需编写一遍就可以对所有目标类进行功能扩展]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>代理模式</tag>
        <tag>JDK动态代理</tag>
        <tag>cglib动态代理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git安装配置与GitHub注册及简单使用]]></title>
    <url>%2F2018%2F03%2F13%2FGit%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%E4%B8%8EGitHub%E6%B3%A8%E5%86%8C%E5%8F%8A%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[GitHub入门级操作记录 一.Git与GitHub作为一个程序员，如果你不懂Git的使用，没有一个GitHub账号，你肯定会被别人嘲笑。GitHub是目前一个非常流行的代码托管平台，同时也是有大量程序员聚集的社区，很多著名的开源项目的代码都存放在这里。GitHub上的代码的管理需要通过本地的版本控制软件Git来操作，下文将详解如何从零开始使用Git及GitHub Git简介Git是一款免费、开源的分布式版本控制系统，可以有效、高速的处理从很小到非常大的项目版本管理。Git是Linux之父Linus Torvalds为了帮助管理Linux内核开发而开发的，所以Git的控制台和Linux的控制台有很多相似之处，命令的风格也一样。Git和SVN的功能类似，不过Git在渐渐的代替SVN称为最主流的版本控制工具 GitHub简介GitHub是一个面向开源及私有软件项目的托管平台，目前已经拥有超过900万开发者用户。随着越来越多的应用程序转移到了云上，Github已经成为了管理软件开发以及发现已有代码的首选方法。 二.配置使用Git和GitHub1.安装GitGit安装程序可以从Git官网下载https://git-scm.com/downloads，如果官网下载速度太慢，也可从CSDN下载http://download.csdn.net/download/eagleuniversityeye/10142597 Git官网： 安装程序： 点击安装程序，全部使用默认设置，一路下一步即可，其中编辑器可以按自己喜好选择： 安装完成后，打开Git程序，如果你选择的是Vim编辑器，则界面就是我这样的： 输入“git”命令，若出现如下显示，则说明git安装成功，可以使用了 2.注册GitHub账号并创建一个仓库GitHub官网注册完成后，打开GitHub首页，创建一个repository代码仓库，每一个代码仓库都是一个单独的项目，可以进行fork，star等操作。 如下图，点击new repository创建一个新仓库 输入项目名，创建 创建完成后页面跳转到下图所示 现在新创建的仓库还是空的，没有任何内容。红线圈起来的是该项目在远程服务器端的地址（HTTPS形式），等一下就向这个地址提交代码 3.使用Git首次提交代码（使用HTTPS）很多教程在这里会让人配置SSH key，但是在之后完全没用到SSH，其实对于刚开始使用GitHub的新手来说完全没有必要去配置SSH key，使用HTTPS就完全足够了。有关SSH是什么和SSH key配置的教程在我的另一篇文章中GitHub配置SSH key 1）在Git中配置全局用户名和邮箱，这个只用在第一次使用时配置一下，之后再使用就不必再配置了。 git config –global user.name “你的用户名”git config –global user.email “你的邮箱” 2）在本地项目文件夹上点击右键，点击Git Bash Here，弹出Git的Vim编辑器 3）输入git命令，提交代码 git init git add 待上传文件夹名这个命令用来添加待上传文件，需要详细解释一下，它用来添加需要上传到GitHub远程服务器的文件，打开项目根目录，就是打开上图Annotation文件夹 根目录下有以上几个文件夹，其中src文件夹，resources文件夹，web文件夹都有项目运行必须的文件，需要把它们全部添加到上传队列即要运行3个git add 命令 git add srcgit add resourcesgit add web 注：不同的项目需要上传的文件也不一样，根据情况选择 接着继续运行命令 git commit -m “first commit”git remote add origin 远程服务器中代码仓库地址（刚才圈红线的地址）git push -u origin master 接着输入用户名和密码完成提交 注：以上几个命令不需要记住，在GitHub的每个空代码仓库的页面都有： 4.使用IDEA连接GitHub，并管理代码每次提交代码都使用Vim编辑器非常不方便，可以在IDEA中进行设置，使用IDEA提交代码 1）检查插件是否齐全IDEA自带Git插件，我们需要下载GitHub的支持插件 2）在IDEA中配置Git只用配置一下Git的开始程序即可，IDEA会自动检测其他内容 3）在IDEA中配置GitHub用户名及密码如图进行配置，配置完成后可以点击Test查看是否配置成功 4）使用IDEA提交代码关于如何使用IDEA和GitHub进行协同操作，则是一个更难更复杂的问题，这里不再赘述]]></content>
      <categories>
        <category>Git/GitHub</category>
      </categories>
      <tags>
        <tag>GitHub</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JQuery的一些简单使用]]></title>
    <url>%2F2018%2F02%2F13%2FJQuery%E7%9A%84%E4%B8%80%E4%BA%9B%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[使用JQuery实现一些小功能，包括表格隔行换色，选项框全选全不选 一、使用JQ完成表格的隔行换色1.需求分析在页面加载的时候让显示用户的表格进行隔行换色显示，效果如下：使用JQ实现 2.技术分析需要使用jquery的选择器(基本选择器、基本过滤选择器)还需要使用jquery的CSS的方法(css(name,value))如果CSS样式已经由美工写好，此时可以使用jquery的CSS类操作 3.步骤分析第一步：引入jquery的类库第二步：直接写页面加载函数第三步：直接使用jquery的选择器(组合选择)拿到需要操作的元素(奇数行和偶数行)第四步：分别使用CSS的方法(css(name,value))对奇数行和偶数行设置背景颜色。 4.代码实现12345678&lt;script type=&quot;text/javascript&quot; src=&quot;../js/jquery-1.8.3.js&quot; &gt;&lt;/script&gt;&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;../css/style.css&quot;/&gt;&lt;script&gt; $(function()&#123; $(&quot;tbody tr:even&quot;).addClass(&quot;even&quot;); $(&quot;tbody tr:odd&quot;).addClass(&quot;odd&quot;); &#125;);&lt;/script&gt; 二、使用JQ完成全选和全不选1.需求分析在系统后台进行人员管理时，进行批量删除，使用jq完成全选和全不选 2.技术分析需要使用jquery的选择器(id选择器、类选择器)需要使用jquery的属性操作方法 prop() 3.步骤分析第一步：引入jquery文件第二步：书写页面加载函数第三步：为上面的复选框绑定单击事件第四步：将下面所有的复选框的选中状态设置成跟上面的一致！ 4.代码实现123456789101112&lt;script type=&quot;text/javascript&quot; src=&quot;../js/jquery-1.8.3.js&quot; &gt;&lt;/script&gt;&lt;script&gt; $(function()&#123; //找到下面所有的复选框并设置属性checked() /*if($(&quot;#select&quot;)[0].checked==true)&#123; $(&quot;.selectOne&quot;).attr(&quot;checked&quot;,true) &#125;*/ $(&quot;#select&quot;).click(function()&#123; $(&quot;.selectOne&quot;).attr(&quot;checked&quot;,this.checked); &#125;); &#125;);&lt;/script&gt;]]></content>
      <categories>
        <category>前端</category>
        <category>JQuery</category>
      </categories>
      <tags>
        <tag>JQuery</tag>
        <tag>页面</tag>
        <tag>前端</tag>
      </tags>
  </entry>
</search>
